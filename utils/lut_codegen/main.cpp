//
// Created by denn on 07.09.2021.
//

#include <string>
#include <iostream>
#include <fstream>

#include "dehancer/gpu/Lib.h"
#include "utils/metal/paths_config.h"

int main(int argc, char** argv) {
  
  if (argc != 6) {
    std::cerr << "Usage: " << argv[0] << " <ocio namespace> <Forward transform 3D Cube file-path> <Inverse transform 3D Cube file-path> <c++-file-path-forward> <c++-file-path-inverse>" << std::endl;
    return EXIT_FAILURE;
  }
  
  int argc_next = 0;
  std::string ocio_namespace = argv[++argc_next];
  
  try {
    
    /**
     * Initializes
     */
    std::vector<std::string> namespaces = {"forward", "inverse"};
    std::vector<std::vector<float>> luts_data;
    
    luts_data.emplace_back();
    luts_data.emplace_back();
    
    auto command_queue = dehancer::DeviceCache::Instance().get_default_command_queue();
    
    if (!command_queue) {
      std::cerr << "Could not get default command queue" << std::endl;
      return EXIT_FAILURE;
    }
    
    dehancer::CLutCubeInput forward_cube(command_queue);
    dehancer::CLutCubeInput inverse_cube(command_queue);
    
    std::string file_forward_path = argv[++argc_next];
    std::string file_inverse_path = argv[++argc_next];
    
    try{
      /***
       * Load forward cube file
       */
      std::ifstream cube_is(file_forward_path, std::ostream::binary);
      cube_is >> forward_cube;
    }
    catch (const dehancer::Error &e) {
      std::cerr << "Error: " << e.message() << " in file: " << file_inverse_path << std::endl;
      return EXIT_FAILURE;
    }
    
    try{
      /***
       * Load forward cube file
       */
      std::ifstream cube_is(file_inverse_path, std::ostream::binary);
      cube_is >> inverse_cube;
    }
    catch (const dehancer::Error &e) {
      std::cerr << "Error: " << e.message() << " in file: " << file_inverse_path << std::endl;
      return EXIT_FAILURE;
    }
    
    auto lut_size = forward_cube.get_lut_size();
    auto lut_channels = forward_cube.get_channels();
    
    //auto identity_cube = dehancer::CLut3DIdentity(command_queue, lut_size);
    
    forward_cube.get_texture()->get_contents(luts_data[0]);
    inverse_cube.get_texture()->get_contents(luts_data[1]);
    //identity_cube.get_texture()->get_contents(luts_data[1]);
    
    /**
     * Generate embedded lut data
     */
    
    int index = 0;
    ++argc_next;
    for(auto& data: luts_data ) {
      
      std::ofstream os(argv[index+argc_next]);
      auto namesp = namespaces[index++];
      
      auto size = lut_size;
      size = size * size * size;
      os << "// " << std::endl
         << "// Generated by Dehancer LUT Builtin Generator" << std::endl
         << "//" << std::endl
         << "#include <stdlib.h>" << std::endl
         << "" << std::endl
         << "namespace dehancer::ocio::"<<ocio_namespace<<"::"<< namesp << " {" << std::endl
         << "\tsize_t __lut__size__ = " << lut_size << ";" << std::endl
         << "\tsize_t __lut__channels__ = " << lut_channels << ";" << std::endl
         << "\tfloat __lut__data__[" << size * lut_channels << "] = {" << std::endl;
      
      size_t i = 0;
      size_t len = data.size();
      for (; i < len; ) {
        os << "\t\t"
           << std::fixed << std::setw(1) << std::setprecision(6)
           << data[i++] << "f, " << data[i++] << "f, " << data[i++] << "f, "
           << "1.0f"; i++;
        if (i < len) os << ", ";
        os << std::endl;
      }
      
      os << std::endl
         << "\t};" << std::endl
         << "}" << std::endl;
    }
    
    std::string hpp_file_string1 = "#pragma once \n\n"
                                   "#include \"dehancer/gpu/ocio/LutParams.h\"\n\n"
                                   "namespace dehancer::ocio::";
    hpp_file_string1.append(ocio_namespace);
  
    std::string hpp_file_string2 = "{\n\n"
                                   "namespace forward {\n"
                                   "      struct lut {\n"
                                   "            static DHCR_LutParameters params;\n"
                                   "      };\n"
                                   "}\n"
                                   "\n"
                                   "namespace inverse {\n"
                                   "        struct lut {\n"
                                   "            static DHCR_LutParameters params;\n"
                                   "        };\n"
                                   "    };\n"
                                   "}\n";
    
    std::string cpp_file_str1 = "#include \"dehancer/gpu/ocio/cs/\"";
    cpp_file_str1.append(ocio_namespace);
    cpp_file_str1.append("\n");
    cpp_file_str1.append("namespace dehancer::ocio::");
    cpp_file_str1.append(ocio_namespace);
  
    std::string cpp_file_str2 = "{\n\n"
                                " namespace forward {\n"
                                "        extern float __lut__data__[];\n"
                                "        extern size_t  __lut__size__;\n"
                                "        extern size_t  __lut__channels__;\n"
                                "    \n"
                                "        DHCR_LutParameters lut::params = {\n"
                                "                .enabled = true,\n"
                                "                .size = static_cast<uint>(forward::__lut__size__),\n"
                                "                .channels = static_cast<uint>(forward::__lut__channels__),\n"
                                "                .data = forward::__lut__data__,\n"
                                "        };\n"
                                "\n"
                                "    }\n"
                                "\n"
                                "    namespace inverse {\n"
                                "\n"
                                "        extern float __lut__data__[];\n"
                                "        extern size_t  __lut__size__;\n"
                                "        extern size_t  __lut__channels__;\n"
                                "    \n"
                                "        DHCR_LutParameters lut::params = {\n"
                                "                .enabled = true,\n"
                                "                .size = static_cast<uint>(__lut__size__),\n"
                                "                .channels = static_cast<uint>(__lut__channels__),\n"
                                "                .data = __lut__data__\n"
                                "        };\n"
                                "    }"
                                "}";
  
  
    std::string file_code_prefix = "./";
    
    {
      auto file = file_code_prefix+ocio_namespace + ".h";
      std::ofstream hpp_os(file);
      std::cout <<"["<<file<<"] >> " << hpp_file_string1 << hpp_file_string2 << std::endl;
      hpp_os << hpp_file_string1 << hpp_file_string2 << std::endl;
    }
  
    {
      auto file = file_code_prefix+ocio_namespace + ".cpp";
      std::ofstream hpp_os(file);
      std::cout <<"["<<file<<"] >> " << cpp_file_str1 << cpp_file_str2 << std::endl;
      std::ofstream cpp_os(file);
      cpp_os << cpp_file_str1 << cpp_file_str2 << std::flush;
    }
    
    /* Release GPU */
    dehancer::DeviceCache::Instance().return_command_queue(command_queue);
    
    return EXIT_SUCCESS;
  }
  catch (const std::exception &e) {
    std::cerr << "Error: " << e.what() << std::endl;
    return EXIT_FAILURE;
  }
  catch (const std::runtime_error &e) {
    std::cerr << "Error: " << e.what() << std::endl;
    return EXIT_FAILURE;
  }
  catch (const dehancer::Error &e) {
    std::cerr << "Error: " << e.message() << std::endl;
    return EXIT_FAILURE;
  }
}


namespace dehancer {
    /**
     * Must be defined in certain plugin
     * @return
     */
    
    extern std::string get_installation_path(){
      return "";
    }
}

#ifdef DEHANCER_GPU_CUDA

namespace dehancer::device {
    
    /**
      * MUST BE defined in certain plugin module
      * @return cuda lib path.
      */
    std::string get_lib_path () {
      return CUDA_KERNELS_LIBRARY;
    }
    
    extern std::size_t get_lib_source (std::string &source) {
      return 0;
    }
}

#elif DEHANCER_GPU_METAL

namespace dehancer::device {
    
    /**
     * MUST BE defined in certain plugin module
     * @return metal lib path.
     */
    std::string get_lib_path () {
      return METAL_KERNELS_LIBRARY;
    }
    
    extern std::size_t get_lib_source (std::string &source) {
      return 0;
    }
}

#endif